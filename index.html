<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Service WorkerによるPWAオフライン対応技術の解説と実装</title>
  <link rel="stylesheet" href="style.css">
  <!-- コードを見やすくするためのシンタックスハイライト(Prism.js)のCSS -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
</head>
<body>

  <header>
    <h1>Service WorkerによるPWAオフライン対応技術の解説と実装</h1>
  </header>

  <main>
    <section>
      <h2>1. はじめに：Webサイトの「当たり前」を覆す技術</h2>
      <p>皆さんは、電車の中やトンネル、電波の悪いカフェなどでWebサイトを見ようとして、こんな画面にがっかりした経験はありませんか？</p>

      <img src="https://via.placeholder.com/800x300.png?text=Chrome+Offline+Dinosaur+Game" alt="インターネットに接続されていません というエラー画面">
      <p>「インターネットに接続されていません」――。<br>
      これは、Webサイトが<strong>オンラインであることが大前提</strong>で成り立っている以上、仕方のないことでした。しかし、この"当たり前"を覆し、Webサイトをまるでスマホアプリのようにオフラインでも利用可能にする技術があります。</p>
      <p>それが、<strong>PWA (Progressive Web Apps)</strong> の中核技術の一つ、<strong>Service Worker（サービスワーカー）</strong>です。</p>
      <p>この記事では、Service WorkerがどのようにしてWebページをオフライン対応させるのか、その仕組みを紐解き、実際に簡単なWebページをオフラインでも閲覧できるようにする手順をハンズオン形式で解説します。</p>
    </section>

    <section>
      <h2>2. Service Workerとは？ - Webサイトの裏で働く”執事”</h2>
      <p>Service Workerとは、一言で言うと<strong>「Webページの裏側で動く、独立したJavaScriptファイル」</strong>です。</p>
      <p>通常のJavaScript (<code>&lt;script&gt;</code>タグで読み込むもの) とは異なり、Webページとは別のスレッドで動作するため、ページを閉じても動き続けることができます。この特性を活かして、プッシュ通知やバックグラウンド同期など、様々な高度な機能を実現します。</p>
      <p>オフライン対応において、Service WorkerはWebページとネットワークの間に立つ<strong>”執事”</strong>のような役割を果たします。</p>

      <img src="https://via.placeholder.com/800x250.png?text=Browser+%3C-%3E+Service+Worker+%3C-%3E+Network" alt="Service Workerの役割を示す図">

      <p>ブラウザが「このページが欲しい」「この画像が欲しい」とリクエストするたびに、Service Workerがそのリクエストを一旦預かります。そして、「そのリクエストされたものは、以前お預かりした<strong>キャッシュ（予備データ）</strong>にございますか？」と確認し、あればネットワーク通信を行わずにキャッシュからデータを返します。</p>
      <p>この<strong>「通信を横取り（インターセプト）して、キャッシュを利用する」</strong>仕組みこそが、オフライン対応の心臓部なのです。</p>
    </section>

    <section>
      <h2>3. オフライン対応の2ステップ</h2>
      <p>Service Workerを使ってオフライン対応を実現するには、大きく分けて2つのステップが必要です。</p>
      <ol>
        <li><strong>インストール (Install)</strong>：初めてサイトに訪れた時に、オフラインでも表示したいファイルをあらかじめキャッシュに保存する。</li>
        <li><strong>有効化とリクエスト処理 (Activate & Fetch)</strong>：サイトへのリクエストを監視し、キャッシュがあればそこから返し、なければネットワークから取得する。</li>
      </ol>
      <p>それでは、実際にコードを見ながら、この2つのステップを実装していきましょう。</p>
    </section>

    <section>
      <h2>4. ハンズオン：実際にオフラインページを作ってみよう！</h2>
      <p>今回は、以下のようなシンプルな構成のWebサイトをオフライン対応させます。</p>
      <pre><code class="language-text">my-offline-site/
├── index.html
├── style.css
├── app.js       (Service Workerを登録するJS)
└── sw.js        (Service Worker本体)</code></pre>

      <h3>Step 1: Service Workerを"登録"する</h3>
      <p>まず、私たちのWebページに「これからService Workerを使いますよ」と教えてあげる必要があります。この処理は、メインのJavaScriptファイル (<code>app.js</code>) に記述します。</p>

      <pre><code class="language-javascript">// app.js

// ブラウザがService Workerに対応しているか確認
if ('serviceWorker' in navigator) {
  // ページが完全に読み込まれた後に、Service Workerファイルを登録
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then(registration => {
        console.log('Service Worker 登録成功:', registration);
      })
      .catch(error => {
        console.log('Service Worker 登録失敗:', error);
      });
  });
}</code></pre>
      <p>このコードにより、ブラウザは <code>sw.js</code> というファイルを特別なプログラムとして認識し、バックグラウンドで実行を開始します。</p>

      <h3>Step 2: "インストール"時にファイルをキャッシュする</h3>
      <p>次に、Service Worker本体である <code>sw.js</code> の中身を書いていきます。Service Workerが初めて登録されると、<code>install</code> というイベントが発生します。このタイミングで、オフラインでも表示したいファイルをキャッシュに保存します。</p>

      <pre><code class="language-javascript">// sw.js

// キャッシュの名前とバージョンを定義
const CACHE_NAME = 'my-offline-cache-v1';
// キャッシュするファイルのリスト
const FILES_TO_CACHE = [
  '/',
  '/index.html',
  '/style.css',
  '/app.js'
];

// `self` はService Worker自身を指す
// installイベントは、Service Workerがインストールされるときに一度だけ実行される
self.addEventListener('install', (event) => {
  // install処理が終わるまで、他のイベントを待機させる
  event.waitUntil(
    // `caches`はブラウザのキャッシュストレージAPI
    // 指定した名前でキャッシュを開く
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('キャッシュを開きました');
        // 指定したファイルをすべてキャッシュに追加する
        return cache.addAll(FILES_TO_CACHE);
      })
  );
});</code></pre>
      <p><code>FILES_TO_CACHE</code> に指定されたファイルが、ユーザーの初回アクセス時にブラウザのキャッシュストレージに保存されます。</p>

      <h3>Step 3: "リクエスト"を横取りしてキャッシュを返す</h3>
      <p>最後に、<code>fetch</code> イベントを実装します。これは、ページが画像やCSSなど、何かしらのリソースをリクエストするたびに発生します。ここでリクエストを横取りし、キャッシュの有無によって応答を切り替えます。</p>

      <pre><code class="language-javascript">// sw.js (続き)

// fetchイベントは、ページがリクエストを送信するたびに発生する
self.addEventListener('fetch', (event) => {
  // ブラウザのデフォルトのfetch処理を上書きする
  event.respondWith(
    // まずキャッシュ内にリクエストと一致するものがあるか探す
    caches.match(event.request)
      .then((response) => {
        // もしキャッシュにあれば、それを返す (ネットワーク通信は発生しない)
        if (response) {
          console.log('キャッシュから応答:', event.request.url);
          return response;
        }

        // キャッシュになければ、通常通りネットワークから取得する
        console.log('ネットワークから取得:', event.request.url);
        return fetch(event.request);
      })
  );
});</code></pre>
      <p>この<code>fetch</code>イベントの実装こそが、オフライン対応の魔法の正体です。キャッシュにデータがあれば、ネットワークに一切アクセスすることなく、瞬時にページを表示させることができるのです。</p>

      <h3>Step 4: 動作を確認してみよう！</h3>
      <p>実装が完了したら、実際に動作を確認してみましょう。Chromeのデベロッパーツールが便利です。</p>
      <ol>
        <li>Webサーバーでページをホストし、一度アクセスします。（ローカルファイルを直接開く方法ではService Workerは動作しないため注意が必要です）</li>
        <li>デベロッパーツールを開き（<code>F12</code>キー or <code>Ctrl+Shift+I</code>）、<code>Application</code> タブを選択します。</li>
        <li>左側のメニューから <code>Service Workers</code> を選び、<code>sw.js</code>が有効化（activated and is running）されていることを確認します。</li>
        <li>次に <code>Network</code> タブに移動し、<code>Offline</code> のチェックボックスをオンにします。</li>
        <li><strong>その状態でページをリロード（<code>F5</code>キー）します。</strong></li>
      </ol>
      
      <img src="https://via.placeholder.com/800x400.png?text=DevTools+Offline+Mode+-+Page+Reloads+Successfully" alt="デベロッパーツールでオフラインにしてもページが表示されている様子">
      
      <p>どうでしょうか？インターネット接続がない状態にも関わらず、ページが表示されたはずです。これがService Workerによるオフライン対応です！</p>
    </section>

    <section>
      <h2>5. まとめ</h2>
      <p>今回は、Service Workerを利用してWebサイトをオフライン対応させる基本的な方法を解説しました。</p>
      <ul>
        <li><strong>Service Worker</strong> は、Webページの裏で動く独立したプログラム。</li>
        <li><strong><code>install</code></strong> イベントで、必要なファイルをあらかじめキャッシュする。</li>
        <li><strong><code>fetch</code></strong> イベントで、リクエストを横取りし、キャッシュがあればそれを返す。</li>
      </ul>
      <p>この仕組みを応用すれば、「キャッシュを優先しつつ、裏側で新しい情報を更新する」といった、より高度なキャッシュ戦略も実装可能です。</p>
      <p>Service Workerを使いこなすことは、ユーザーに快適な体験を提供する上で非常に強力な武器となります。ぜひ、ご自身のポートフォリオサイトなどにも導入してみてはいかがでしょうか。</p>
    </section>

    <hr>
    
    <footer>
      <p class="time-record">本コンテンツの作成時間（HTML/CSS/JavaScriptの設計・実装を含む）：約6時間</p>
    </footer>

  </main>

  <!-- Service Workerを登録するスクリプト -->
  <script src="app.js" defer></script>
  <!-- コードを見やすくするためのシンタックスハイライト(Prism.js)のJS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
